<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="Demo.RulesBuilder.RestHandler">
<IncludeCode>%IKPublic</IncludeCode>
<IncludeGenerator>%IKPublic</IncludeGenerator>
<Super>%CSP.REST</Super>
<TimeCreated>63839,41473.869177</TimeCreated>

<Parameter name="IKPAGESIZE">
<Type>INTEGER</Type>
<Default>1000</Default>
</Parameter>

<Parameter name="IKPFILTERMODE">
<Description>
As the app only shows spread, this filter mode will do all we need with less work than
the classic $$$FILTERALLANDSORT</Description>
<Type>INTEGER</Type>
<Expression>$$$FILTERSPREADANDSORT</Expression>
</Parameter>

<Parameter name="JSONFORMATPARAMS">
<Type>STRING</Type>
<Default>aelotwu</Default>
</Parameter>

<XData name="UrlMap">
<XMLNamespace>http://www.intersystems.com/urlmap</XMLNamespace>
<Data><![CDATA[
<Routes>

<Route Url="/Domain/:domain/Features" Method="GET" Call="GetFeatures" />

<Route Url="/Domain/:domain/Sentences/Entity/:entity" Method="GET" Call="GetSentencesByEntity"/>

<Route Url="/Domain/:domain/Entities/" Method="GET" Call="GetEntities"/>
<Route Url="/Domain/:domain/Entities/:string" Method="GET" Call="GetEntities"/>

<Route Url="/Domain/:domain/Dictionaries" Method="GET" Call="GetDictionaries"/>
<Route Url="/Domain/:domain/Dictionaries" Method="POST" Call="UpdateDictionaries"/>

<Route Url="/Domain/:domain/RuleDefinitions" Method="GET" Call="GetRuleDefs"/>
<Route Url="/Domain/:domain/RuleDefinitions" Method="POST" Call="UpdateRuleDef"/>

<Route Url="/Domain/:domain/ExtractionResults/:docName" Method="GET" Call="GetExtractionResults"/>

<Route Url="/Domain/:domain/Index" Method="POST" Call="Index"/>

<Route Url="/Domain/:domain/Extract/:parID/:srcId" Method="GET" Call="ExtractParagraph"/>

<Route Url="/Domain/:domain/Parse" Method="POST" Call="Parse"/>
</Routes>
]]></Data>
</XData>

<Method name="GetDictionaries">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDomainId:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		set tJSON = ##class(%ZEN.proxyObject).%New()
		
		set tJSON.dictionaries = ##class(%ListOfObjects).%New()
		set tSC = ##class(%iKnow.Matching.DictionaryAPI).GetDictionaries(.tDicts, pDomainId, 0, 0)
		quit:$$$ISERR(tSC)
		set i = ""
		for {
			set i = $order(tDicts(i), 1, tDictData)
			quit:i=""
			
			set tDict = ##class(%ZEN.proxyObject).%New()
			set tDict.id = $lg(tDictData,1)
			set tDict.name = $lg(tDictData,2)
			set tDict.items = ##class(%ListOfObjects).%New()
			do tJSON.dictionaries.Insert(tDict)
			
			set tSC = ##class(%iKnow.Matching.DictionaryAPI).GetDictionaryItems(.tItems, pDomainId, tDict.id, 0, 0)
			quit:$$$ISERR(tSC)
			set j = ""
			for {
				set j = $order(tItems(j),1,tItemData)
				quit:j=""
				
				set tItem = ##class(%ZEN.proxyObject).%New()
				set tItem.id = $lg(tItemData,1)
				set tItem.name = $lg(tItemData,2)
				set tItem.uri = $lg(tItemData,3)
				set tItem.terms = ##class(%ListOfObjects).%New()
				do tDict.items.Insert(tItem)
				
				set tSC = ##class(%iKnow.Matching.DictionaryAPI).GetDictionaryTermsByItem(.tTerms, pDomainId, tItem.id, 0, 0)
				quit:$$$ISERR(tSC)
				set k = ""
				for {
					set k = $order(tTerms(k), 1, tTermData)
					quit:k=""
					
					set tTerm = ##class(%ZEN.proxyObject).%New()
					set tTerm.id = $lg(tTermData,1)
					set tTerm.string = $lg(tTermData,2)
					do tItem.terms.Insert(tTerm)
				}
			}
		}
		
		
		// TODO: remove
		set tJSON.DictionaryTerms = ##class(%ListOfObjects).%New()
		
		set tStatement = ##class(%SQL.Statement).%New()
		set tSC = tStatement.%Prepare("SELECT ID FROM %iKnow_Objects.DictionaryTerm WHERE DomainId = ?")
		quit:$$$ISERR(tSC)
		
		set tResult = tStatement.%Execute(pDomainId)
		while tResult.%Next() {
			set tDictionaryTerm = ##class(%iKnow.Objects.DictionaryTerm).%OpenId(tResult.%GetData(1))
			set tProxy = ##class(%ZEN.proxyObject).%New()
			set tProxy.Term = tDictionaryTerm.String
			set tProxy.Item = tDictionaryTerm.DictionaryItem.Name
			set tProxy.ItemURI = tDictionaryTerm.DictionaryItem.URI
			set tProxy.Dictionary = tDictionaryTerm.Dictionary.Name
			do tJSON.DictionaryTerms.Insert(tProxy)
		}
		
		do tJSON.%ToJSON(,..#JSONFORMATPARAMS)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit ..ErrorHandler(tSC)
]]></Implementation>
</Method>

<Method name="UpdateDictionaries">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDomainId:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		set tJSONString = ""
		while '%request.Content.AtEnd {
			set tJSONString = tJSONString_$zcvt(%request.Content.ReadLine(),"I","UTF8")
		}
		set tSC = ##class(%ZEN.Auxiliary.jsonProvider).%ConvertJSONToObject(tJSONString,,.tRequest)
		quit:$$$ISERR(tSC)
		
		if (tRequest.delete) {
			if (tRequest.type = "dict") {
				set tSC = ##class(%iKnow.Matching.DictionaryAPI).DropDictionary(pDomainId, tRequest.id)
			} elseif (tRequest.type = "item") {
				set tSC = ##class(%iKnow.Matching.DictionaryAPI).DropDictionaryItem(pDomainId, tRequest.id)
			} elseif (tRequest.type = "term") {
				set tSC = ##class(%iKnow.Matching.DictionaryAPI).DropDictionaryTerm(pDomainId, tRequest.id)
			}
			quit
		}
		
		if (tRequest.create) {
			if (tRequest.type = "dict") {
				do ##class(%iKnow.Matching.DictionaryAPI).CreateDictionary(pDomainId, tRequest.name,,,, .tSC)
			} elseif (tRequest.type = "item") {
				do ##class(%iKnow.Matching.DictionaryAPI).CreateDictionaryItem(pDomainId, tRequest.dictId, tRequest.name, tRequest.uri,, .tSC)
			} elseif (tRequest.type = "term") {
				do ##class(%iKnow.Matching.DictionaryAPI).CreateDictionaryTerm(pDomainId, tRequest.itemId, tRequest.string,, .tSC)
			}
			quit
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit ..ErrorHandler(tSC)
]]></Implementation>
</Method>

<Method name="GetExtractionResults">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDomainId:%Integer,pSourceId:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		set tJSON = ##class(%ZEN.proxyObject).%New()
		set tJSON.ExtractionResults = ##class(%ListOfObjects).%New()
		
		set tStatement = ##class(%SQL.Statement).%New()
		set tSC = tStatement.%Prepare("SELECT ID FROM Demo_RulesBuilder.ExtractionResult WHERE DomainId = ? AND SourceId = ? AND Score > 0 ORDER BY Score DESC")
		quit:$$$ISERR(tSC)
		set tResult = tStatement.%Execute(pDomainId, pSourceId)
		while tResult.%Next() {
			set tExtract = ##class(Demo.RulesBuilder.ExtractionResult).%OpenId(tResult.%GetData(1))
			set tProxy = ##class(%ZEN.proxyObject).%New()
			set tProxy.HighlightingResult = tExtract.HighlightingResult
			set tProxy.MeetsMandatory = tExtract.MeetsMandatory
			set tProxy.MeetsOrder = tExtract.MeetsOrder
			set tProxy.Score = tExtract.Score
			
			set tProxy.RuleDefinition = ##class(%ZEN.proxyObject).%New()
			set tProxy.RuleDefinition.DomainId = tExtract.RuleDefinition.DomainId
			set tProxy.RuleDefinition.Name = tExtract.RuleDefinition.Name
			set tProxy.RuleDefinition.MinimumScore = tExtract.RuleDefinition.MinimumScore
			set tProxy.RuleDefinition.EnforceSequence = tExtract.RuleDefinition.EnforceSequence
			set tProxy.RuleDefinition.StringRepresentation = tExtract.RuleDefinition.StringRepresentation
			set tProxy.RuleDefinition.Elements = ##class(%ListOfObjects).%New()
			for i = 1:1:tExtract.RuleDefinition.Elements.Count() {
				set tElem = ##class(%ZEN.proxyObject).%New()
				set tElem.Name = tExtract.RuleDefinition.Elements.GetAt(i).Name
				set tElem.Count = tExtract.RuleDefinition.Elements.GetAt(i).Count
				set tElem.Negation = tExtract.RuleDefinition.Elements.GetAt(i).Negation
				set tElem.Type = tExtract.RuleDefinition.Elements.GetAt(i).Type
				do tProxy.RuleDefinition.Elements.Insert(tElem)
			}
			
			set tProxy.MatchedElements = ##class(%ListOfObjects).%New()
			for i = 1:1:tExtract.MatchedElements.Count() {
				set tMatchedElem = tExtract.MatchedElements.GetAt(i)
				set tElem = ##class(%ZEN.proxyObject).%New()
				set tElem.RuleElement = tProxy.RuleDefinition.Elements.GetAt(tMatchedElem.RuleElementSeq)
				set tElem.MatchScore = tMatchedElem.MatchScore
				set tElem.Color = tMatchedElem.Color
				set tElem.DictionaryTermId = tMatchedElem.DictionaryTermId
				set tElem.Literal = tMatchedElem.Literal
				set tElem.FirstEntOccId = tMatchedElem.FirstEntOccId
				set tElem.Negation = tMatchedElem.Negation
				set tElem.IsSecondary = tMatchedElem.IsSecondary
				
				set tDictionaryTerm = ##class(%iKnow.Objects.DictionaryTerm).PKINDEXOpen(pDomainId, tMatchedElem.DictionaryTermId)
				set tElem.DictionaryTerm = ##class(%ZEN.proxyObject).%New()
				set tElem.DictionaryTerm.String = tDictionaryTerm.String
				
				// derive value
				set tEntOccId = "", tValue = ""
				while 1 {
					set tOutput = tMatchedElem.EntOccOutput.GetNext(.tEntOccId)
					quit:tEntOccId=""
					continue:tOutput=""
					set tValue = tValue_$lb(tOutput)
				}
				
				// if no output is found, use the item name
				set:tValue="" tValue = $lb(tDictionaryTerm.DictionaryItem.Name)
				set tElem.Value = $lts(tValue)
				
				do tProxy.MatchedElements.Insert(tElem)
			}
			do tJSON.ExtractionResults.Insert(tProxy)
		}
		
		do tJSON.%ToJSON(,..#JSONFORMATPARAMS)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit ..ErrorHandler(tSC)
]]></Implementation>
</Method>

<Method name="ExtractParagraph">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDomainId:%Integer,pParagraphID:%Integer,pSourceId:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		
		&SQL(DELETE FROM Demo_RulesBuilder.ExtractionResult WHERE DomainId = :pDomainId AND SourceId = :pSourceId)
		set tStatement = ##class(%SQL.Statement).%New()
		set tSC = tStatement.%Prepare("SELECT ID FROM Demo_RulesBuilder.RuleDefinition WHERE DomainId = ?")
		quit:$$$ISERR(tSC)
		set tResult = tStatement.%Execute(pDomainId) 
		while tResult.%Next() {
			set tSC = ##class(RuleDefinition).%OpenId(tResult.%Get("ID")).CheckMatches(pSourceId, pParagraphID)
			quit:$$$ISERR(tSC)
		}
		quit:$$$ISERR(tSC)
		
		set tSC = ..GetExtractionResults(pDomainId, pSourceId)
		quit:$$$ISERR(tSC)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="Index">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDomainId:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		set tJSONString = ""
		while '%request.Content.AtEnd {
			set tJSONString = tJSONString_$zcvt(%request.Content.ReadLine(),"I","UTF8")
		}
		set tSC = ##class(%ZEN.Auxiliary.jsonProvider).%ConvertJSONToObject(tJSONString,,.tJSON)
		quit:$$$ISERR(tSC)
		
		
		set tDomainName = $system.iKnow.GetDomainName(pDomainId)
		set tDocName = tJSON.doc.documentName
		
		// first clean up old records and persist paragraphs
		&SQL(DELETE FROM Demo_RulesBuilder.Paragraph WHERE DocumentName = :tDocName)
		&SQL(DELETE FROM Demo_RulesBuilder.ExtractionResult WHERE DomainId = :pDomainId AND DocumentName = :tDocName)
		set tSC = ##class(Demo.RulesBuilder.Paragraph).SaveFromProxy(tJSON.doc)
		quit:$$$ISERR(tSC)

		// now update domain
		set tSC = ##class(Demo.RulesBuilder.ParagraphDomain).LoadDocument(tDocName)
		quit:$$$ISERR(tSC)
		
		set tResult = ##class(%ZEN.proxyObject).%New()
		set tResult.paragraphs = ##class(%ListOfObjects).%New()
		set tFilter = ##class(%iKnow.Filters.SimpleMetadataFilter).%New(pDomainId,"DocumentName","=",tDocName)
		set tSC = ##class(%iKnow.Queries.SourceAPI).GetByDomain(.tSources, pDomainId, 0, 0, tFilter)
		quit:$$$ISERR(tSC)
		set tMarkup("MATCH")="<b>"
		set tMarkup("ATTRIBUTE",$$$IKATTNEGATION) = "<font style='color: DarkRed;'>"
		set i = ""
		for {
			set i = $order(tSources(i),1,tSrcData)
			quit:i=""
			set tPar = ##class(Paragraph).%OpenId($piece($lg(tSrcData,2),":",*)).ToProxy(pDomainId,.tMarkup,-1)
			set tPar.sourceId = $lg(tSrcData,1)
			
			// add flag for *any* match
			set tSC = ##class(%iKnow.Matching.MatchingAPI).GetMatchesBySourceId(.tMatches, pDomainId, tPar.sourceId,, 0)
			quit:$$$ISERR(tSC)
			set tPar.matchCount = $o(tMatches(""),-1)
			
			do tResult.paragraphs.Insert(tPar)
		}
		quit:$$$ISERR(tSC)
		
		set:$data(%response) %response.ContentType="application/json"
		do tResult.%ToJSON(,..#JSONFORMATPARAMS)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit ..ErrorHandler(tSC)
]]></Implementation>
</Method>

<Method name="Parse">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDomainId:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		set tJSONString = ""
		while '%request.Content.AtEnd {
			set tJSONString = tJSONString_$zcvt(%request.Content.ReadLine(),"I","UTF8")
		}
		set tSC = ##class(%ZEN.Auxiliary.jsonProvider).%ConvertJSONToObject(tJSONString,,.tJSON)
		quit:$$$ISERR(tSC)
		
		// TODO: de-hardcode separator?
		set tSC = ##class(Demo.RulesBuilder.Paragraph).ParseString(.tObject, tJSON.Text,, $c(10))
		quit:$$$ISERR(tSC)
		
		set:$data(%response) %response.ContentType="application/json"
		do tObject.%ToJSON(,..#JSONFORMATPARAMS)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit ..ErrorHandler(tSC)
]]></Implementation>
</Method>

<Method name="GetRuleDefs">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDomainId:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		set tJSON = ##class(%ZEN.proxyObject).%New()
		set tJSON.RuleDefinitions = ##class(%ListOfObjects).%New()
		
		set tStatement = ##class(%SQL.Statement).%New()
		set tSC = tStatement.%Prepare("SELECT ID FROM Demo_RulesBuilder.RuleDefinition WHERE DomainId = ?")
		quit:$$$ISERR(tSC)
		set tResult = tStatement.%Execute(pDomainId)
		while tResult.%Next() {
			set tRuleDef = ##class(Demo.RulesBuilder.RuleDefinition).%OpenId(tResult.%GetData(1))
			set tProxy = ##class(%ZEN.proxyObject).%New()
			set tProxy.ID = tResult.%GetData(1)
			set tProxy.DomainId = tRuleDef.DomainId
			set tProxy.Name = tRuleDef.Name
			set tProxy.EnforceSequence = tRuleDef.EnforceSequence
			set tProxy.StringRepresentation = tRuleDef.StringRepresentation
			set tProxy.Elements = ##class(%ListOfObjects).%New()
			for i = 1:1:tRuleDef.Elements.Count() {
				set tElem = ##class(%ZEN.proxyObject).%New()
				set tElem.Name = tRuleDef.Elements.GetAt(i).Name
				set tElem.Count = tRuleDef.Elements.GetAt(i).Count
				set tElem.Negation = tRuleDef.Elements.GetAt(i).Negation
				set tElem.Type = tRuleDef.Elements.GetAt(i).Type
				if (tElem.Type="dictionary") {
					set tElem.DictName = tElem.Name
					set tElem.ItemURI = "ANY"
					if (##class(%iKnow.Matching.DictionaryAPI).GetDictionaryId(pDomainId, tElem.DictName)<=0) {
						set tSC = $$$ERROR($$$GeneralError, "WARNING: dictionary '"_tElem.DictName_"' is referred in rule '"_tRuleDef.Name_"' and no longer present!")
					}
				} else {
					set tElem.ItemURI = tElem.Name
					set tDictItemId = ##class(%iKnow.Matching.DictionaryAPI).GetDictionaryItemIdByURI(pDomainId, tElem.Name)
					if (tDictItemId <= 0) {
						set tSC = $$$ERROR($$$GeneralError, "WARNING: dictionary item '"_tElem.ItemURI_"' is referred in rule '"_tRuleDef.Name_"' and no longer present!")
					} else {
						set tDictItem = ##class(%iKnow.Objects.DictionaryItem).PKINDEXOpen(pDomainId, tDictItemId)
						set tElem.DictName = tDictItem.Dictionary.Name
					}
				}
				do tProxy.Elements.Insert(tElem)
			}
			do tJSON.RuleDefinitions.Insert(tProxy)
		}
		
		// nicen error, so we can at least try to recover
		if $$$ISERR(tSC) {
			set tJSON.ErrorNum = $system.Status.GetErrorCodes(tSC)
			set tJSON.ErrorMessage = $system.Status.GetErrorText(tSC)
			set tSC = $$$OK
		}
		
		do tJSON.%ToJSON(,..#JSONFORMATPARAMS)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit ..ErrorHandler(tSC)
]]></Implementation>
</Method>

<Method name="UpdateRuleDef">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDomainId:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		set tJSONString = ""
		while '%request.Content.AtEnd {
			set tJSONString = tJSONString_$zcvt(%request.Content.ReadLine(),"I","UTF8")
		}
		set tSC = ##class(%ZEN.Auxiliary.jsonProvider).%ConvertJSONToObject(tJSONString,,.tRequest)
		quit:$$$ISERR(tSC)
		
		if (tRequest.delete || tRequest.obj.ID) { // update = delete first
			set tSC = ##class(RuleDefinition).%DeleteId(tRequest.obj.ID)
			quit:tRequest.delete
		}
		
		set tRuleDef = ##class(RuleDefinition).%New()
		set tRuleDef.DomainId = pDomainId
		set tRuleDef.Name = tRequest.obj.Name
		set tRuleDef.EnforceSequence = tRequest.obj.EnforceSequence
		set tRuleDef.Elements = ##class(%ListOfObjects).%New()
		for i = 1:1:tRequest.obj.Elements.Count() {
			set tRequestElem = tRequest.obj.Elements.GetAt(i)
			set tElem = ##class(RuleDefinitionElement).%New()
			set tElem.Type = $s(tRequestElem.ItemURI="ANY":"dictionary", 1:"item")
			set tElem.Name = $s(tRequestElem.ItemURI="ANY":tRequestElem.DictName, 1:tRequestElem.ItemURI)
			set tElem.Count = tRequestElem.Count
			set tElem.Negation = tRequestElem.Negation
			do tRuleDef.Elements.Insert(tElem)
		}
		
		set tSC = tRuleDef.%Save()
		
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit ..ErrorHandler(tSC)
]]></Implementation>
</Method>

<Method name="GetSources">
<Description>
Retrieves all sources (including full text and metadata) in the domain and prints them as JSON</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDomainId:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		set tSC = ..GetSourcesInternal(pDomainId)
		quit:$$$ISERR(tSC)
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit ..ErrorHandler(tSC)
]]></Implementation>
</Method>

<Method name="GetFilterForRequestSet">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDomainId</FormalSpec>
<Private>1</Private>
<ReturnType>%iKnow.Filters.Filter</ReturnType>
<Implementation><![CDATA[
	quit:'$d(%request.Data("SourceFilter",1),tFilterSet) ""
	quit ""
]]></Implementation>
</Method>

<Method name="GetSentencesByEntity">
<Description><![CDATA[
Retrieves all sentences (including full text) in the domain containing <var>pEntity</var> and prints them as JSON]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDomainId:%Integer,pEntity:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		set:$data(%response) %response.ContentType="application/json"
		
		set tEntityId = ##class(%iKnow.Queries.EntityAPI).GetId(pDomainId, pEntity)
		set tHighlight("ENTITY", tEntityId) = "<b class=""entity"" title=""entity '"_$zcvt(pEntity,"O","HTML")_"'"">"
		
		set tSC = ##class(%iKnow.Queries.SentenceAPI).GetByEntities(.tSentences, pDomainId, pEntity, ..GetFilterForRequestSet(pDomainId), 1, ..#IKPAGESIZE)
		quit:$$$ISERR(tSC)
		
		set tJSON = ##class(%ZEN.proxyObject).%New()
		set tJSON.Sentences = ##class(%ListOfObjects).%New()
		set i = ""
		for {
			set i = $order(tSentences(i), 1, tSentData)
			quit:i=""
			set tSentId = $lg(tSentData,3)
			set tProxy = ##class(%ZEN.proxyObject).%New()
			set tProxy.SourceId = $lg(tSentData,1)
			set tProxy.ExternalId = $lg(tSentData,2)
			set tProxy.SentenceId = $lg(tSentData,3)
			set tProxy.Text = ..GetHighlightedSentence(pDomainId, tProxy.SentenceId, .tHighlight, .tSC)
			quit:$$$ISERR(tSC)
			
			do tJSON.Sentences.Insert(tProxy)
		}
		quit:$$$ISERR(tSC)
		
		do tJSON.%ToJSON(,..#JSONFORMATPARAMS)
		
    } catch (ex) {
        set tSC=ex.AsStatus()
    }
	quit ..ErrorHandler(tSC)
]]></Implementation>
</Method>

<Method name="GetSourcesInternal">
<Description>
Utility method to print a list of sources to JSON</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pDomainId:%Integer,pFilter:%iKnow.Filters.Filter="",pFilterByEntity:%String="",&pHighlight,pGetMetadata:%Boolean=1]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		set:$data(%response) %response.ContentType="application/json"
		
		set tJSON = ##class(%ZEN.proxyObject).%New()
		set tJSON.Sources = ##class(%ListOfObjects).%New()
		set tSC = ##class(%iKnow.Queries.SourceAPI).GetByDomain(.tResult, pDomainId, 1, ..#IKPAGESIZE,  pFilter)
		quit:$$$ISERR(tSC)
		set i = ""
		for {
			set i = $order(tResult(i), 1, tData)
			quit:i=""
			
			set tSrcId = $lg(tData,1)
			set tProxy = ##class(%ZEN.proxyObject).%New()
			set tProxy.SourceId = tSrcId
			
			// add fulltext
			set tProxy.FullText = ..GetHighlightedSource(pDomainId, tSrcId, pFilterByEntity,, .pHighlight, .tSC)
			quit:$$$ISERR(tSC)
			
			// add metadata
			if pGetMetadata {
				set tSC = ##class(%iKnow.Queries.MetadataAPI).GetValuesById(.tMetadata, pDomainId, tSrcId)
				quit:$$$ISERR(tSC)
				set j = ""
				for {
					set j = $order(tMetadata(j),1,tMD)
					quit:j=""
					set tFieldName = $li(tMD,2)
					continue:tFieldName="DateIndexed"
					set $property(tProxy,tFieldName) = $lg(tMD,3)
				}
			}
			
			do tJSON.Sources.Insert(tProxy)
		}
		
		do tJSON.%ToJSON(,..#JSONFORMATPARAMS)
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit ..ErrorHandler(tSC)
]]></Implementation>
</Method>

<Method name="GetHighlightedSource">
<Description><![CDATA[
Retrieves a highlighted summary of the text in source <var>pSourceId</var>, optionally filtered to the
sentences containing <var>pFilterByEntity</var>. At most <var>pMaxSentences</var> will be returned.
Any markup in <var>pHighlight</var> is appended with default highlighting of negations]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pDomainId:%Integer,pSourceId:%Integer,pFilterByEntity:%String="",pMaxSentences:%Integer=5,&pHighlight,*pSC:%Status=$$$OK]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set pSC = $$$OK, tString = ""
	try {
		
		// first select by entities
		if (pFilterByEntity'="") {
			set pHighlight("ENTITY", pFilterByEntity) = "<b class=""entity"" title=""entity '"_$zcvt(pFilterByEntity,"O","HTML")_"'"">"
			set pSC = ##class(%iKnow.Queries.SentenceAPI).GetByEntities(.tSentences, pDomainId, pFilterByEntity, $lb(pSourceId), 0)
			quit:$$$ISERR(pSC)
		} elseif $d(pHighlight("ENTITY")) {
			set tEntity = "", tEntityList=""
			for {
				set tEntity = $order(pHighlight("ENTITY",tEntity))
				quit:tEntity=""
				set tEntityList = tEntityList _ $lb(tEntity)
			}
			set pSC = ##class(%iKnow.Queries.SentenceAPI).GetByEntities(.tSentences, pDomainId, tEntityList, $lb(pSourceId), 0)
			quit:$$$ISERR(pSC)
		}
		set i = "", tSentIDs = ""
		for {
			set i = $order(tSentences(i),1,tSentData)
			quit:i=""
			set tSentIDs = tSentIDs _ $li(tSentData,3,3)
		}
		
		// now fetch the sentences of this source...
		// first selected by whether they are in tSentIDs, then based on summary relevance
		// and back in natural order
		set tSQL = "SELECT SentenceId, SummaryRelevance FROM %iKnow_Objects.Sentence WHERE DomainId = ? AND SourceId = ?"
		set tSQL = "SELECT TOP ? * FROM ("_tSQL_") ORDER BY CASE WHEN (SentenceId %INLIST ?) THEN 1 ELSE 0 END DESC, SummaryRelevance DESC"
		set tSQL = "SELECT * FROM ("_tSQL_") ORDER BY SentenceId ASC"
		set tStatement = ##class(%SQL.Statement).%New()
		set pSC = tStatement.%Prepare(tSQL)
		quit:$$$ISERR(pSC)
		set tResult = tStatement.%Execute(pMaxSentences, pDomainId, pSourceId, tSentIDs)
		
		
		set tSource = ##class(%iKnow.Objects.Source).PKINDEXOpen(pDomainId, pSourceId)
		set tPrevSentId = tSource.FirstSentenceId-1, tSentId=""
		while tResult.%Next() {
			set tSentId = tResult.%Get("SentenceId")
			
			set:(tPrevSentId'=(tSentId-1)) tString = tString_" ... "
			set tPrevSentId = tSentId
			
			set tString = tString _ ..GetHighlightedSentence(pDomainId, tSentId, .pHighlight, .pSC)
			quit:$$$ISERR(pSC)
		}
		if tSentId'=(tSource.FirstSentenceId+tSource.SentenceCount-1) {
			set tString = tString _ " ..."
		}
		
	} catch (ex) {
		set pSC = ex.AsStatus()
	}
	quit tString
]]></Implementation>
</Method>

<Method name="GetHighlightedSentence">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pDomainId:%Integer,pSentenceId:%Integer,&pHighlight,*pSC:%Status]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set pSC = $$$OK, tSentence = ""
	try {
		// default highlighting
		set tHighlight("ATTRIBUTE", $$$IKATTSENPOSITIVE) = "<span class=""sent-pos"">"
		set tHighlight("ATTRIBUTE", $$$IKATTSENNEGATIVE) = "<font class=""sent-neg"">"
		set tHighlight("ATTRIBUTE", $$$IKATTNEGATION) = "<u class=""negation"">"
		
		// append/override with explicit highlighting requirements
		merge tHighlight = pHighlight
		
		set tSentence = ##class(%iKnow.Queries.SentenceAPI).GetHighlighted(pDomainId, pSentenceId, .tHighlight,,, .pSC)
		
	} catch (ex) {
		set pSC = ex.AsStatus()
	}
	quit tSentence
]]></Implementation>
</Method>

<Method name="GetEntities">
<Description><![CDATA[
Retrieves the top entities similar to <var>pString</var> and prints them to JSON]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDomainId:%Integer,pString:%String(MAXLEN="")</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		if ($g(pString)="") {
			set tSC = ##class(%iKnow.Queries.EntityAPI).GetTop(.tResult, pDomainId, 1, ..#IKPAGESIZE, ..GetFilterForRequestSet(pDomainId), ..#IKPFILTERMODE)
			quit:$$$ISERR(tSC)
		} else {
			set tSC = ##class(%iKnow.Queries.EntityAPI).GetSimilar(.tResult, pDomainId, pString, 1, ..#IKPAGESIZE, ..GetFilterForRequestSet(pDomainId), ..#IKPFILTERMODE)
			quit:$$$ISERR(tSC)
		}
		
		set:$data(%response) %response.ContentType="application/json"
		set tJSON = ##class(%ZEN.proxyObject).%New()
		set tJSON.Seed = $g(pString)
		
		set tSC = ..EntityResultToJSON(.tResult, .tEntities)
		quit:$$$ISERR(tSC)
		
		set tJSON.Entities = tEntities
		do tJSON.%ToJSON(,..#JSONFORMATPARAMS)
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit ..ErrorHandler(tSC)
]]></Implementation>
</Method>

<Method name="EntityResultToJSON">
<Description>
Utility method for converting an array of entities to JSON</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pResult,*pJSONArray]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		set i = "", pJSONArray = ##class(%ListOfObjects).%New()
		for {
			set i = $order(pResult(i), 1, tData)
			quit:i=""
			
			set tProxy = ##class(%ZEN.proxyObject).%New()
			set tProxy.EntityValue = $lg(tData,2)
			set tProxy.Frequency = $lg(tData,3)
			set tProxy.Spread = $lg(tData,4)
			do pJSONArray.Insert(tProxy)
		}
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="ErrorHandler">
<Description><![CDATA[
Simple error handler, converting a <class>%Status</class> object to a JSON representation.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Stat:%Status</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if $$$ISERR(Stat) {
		set errorcode=$piece(##class(%SYSTEM.Status).GetErrorCodes(Stat),",")
		set errormessage=##class(%SYSTEM.Status).GetOneStatusText(Stat)
		set errobj=##class(%ZEN.proxyObject).%New()
		set errobj.ErrorNum=errorcode
		set errobj.ErrorMessage=errormessage
		Set %response.ContentType="application/json"
		Do ##class(%ZEN.Auxiliary.jsonProvider).%ObjectToJSON(errobj)
		set errobj=""
	}
	quit $$$OK
]]></Implementation>
</Method>

<Method name="GetFeatures">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDomainId:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		set:$data(%response) %response.ContentType="application/json"
		
		set tJSON = ##class(%ZEN.proxyObject).%New()
		
		set tDomain = ##class(%iKnow.Domain).%OpenId(pDomainId)
		if '$isobject(tDomain) { set tSC = $$$ERROR($$$IKNoDomainWithId, pDomainId) }
		set tPackageName = tDomain.GetParameter($$$IKPPACKAGE)
		set tJSON.HasTables = (tPackageName'="")
		
		if tJSON.HasTables {
			set tSQL = "SELECT TOP 1 %ID FROM "_$tr(tPackageName,".","_")_".PathAttribute WHERE AttributeTypeId IN (5,6) UNION SELECT TOP 1 %ID FROM "_$tr(tPackageName,".","_")_".SentenceAttribute WHERE AttributeTypeId IN (5,6)"
			set tResult = ##class(%SQL.Statement).%ExecDirect(,tSQL)
			set tJSON.HasSentiment = (tResult.%Next() && tResult.%GetData(1))
		} else {
			set tJSON.HasSentiment = 0
		}
		
		set tJSON.MinSearchLength = tDomain.GetParameter($$$IKPMINTOPCONCEPTLENGTH)
		
		// write JSON
		do tJSON.%ToJSON(, ..#JSONFORMATPARAMS)
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit ..ErrorHandler(tSC)
]]></Implementation>
</Method>
</Class>
</Export>
